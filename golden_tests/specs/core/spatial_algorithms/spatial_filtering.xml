<?xml version="1.0" encoding="UTF-8"?>
<golden_test xmlns="http://golden-tests.org/schema">
  <metadata>
    <id>spatial_filtering_gaussian</id>
    <version>1.0</version>
    <description>Test Gaussian spatial filtering and smoothing operations on 3D volumes</description>
    <tags>
      <tag>spatial_algorithms</tag>
      <tag>filtering</tag>
      <tag>smoothing</tag>
      <tag>core</tag>
    </tags>
  </metadata>
  
  <semantic_description>
    <purpose>
      Validate Gaussian spatial filtering operations including kernel generation,
      convolution, and smoothing with different FWHM values and boundary handling.
    </purpose>
    <algorithm>
      1. Create a 5x5x5 volume with a central peak and edge artifacts
      2. Apply Gaussian smoothing with FWHM = 1.0 voxels
      3. Apply Gaussian smoothing with FWHM = 2.0 voxels
      4. Test kernel generation for 1D, 2D, and 3D cases
      5. Verify smoothing reduces peak intensity and spreads signal
      6. Test boundary conditions (zero-padding behavior)
      7. Validate kernel normalization (sum = 1)
    </algorithm>
  </semantic_description>
  
  <inputs>
    <array>
      <name>test_volume</name>
      <dimensions>5 5 5</dimensions>
      <values>
        0 0 0 0 0
        0 1 2 1 0
        0 2 10 2 0
        0 1 2 1 0
        0 0 0 0 0
        
        0 1 2 1 0
        1 2 5 2 1
        2 5 20 5 2
        1 2 5 2 1
        0 1 2 1 0
        
        0 2 10 2 0
        2 5 20 5 2
        10 20 100 20 10
        2 5 20 5 2
        0 2 10 2 0
        
        0 1 2 1 0
        1 2 5 2 1
        2 5 20 5 2
        1 2 5 2 1
        0 1 2 1 0
        
        0 0 0 0 0
        0 1 2 1 0
        0 2 10 2 0
        0 1 2 1 0
        0 0 0 0 0
      </values>
    </array>
    <parameters>
      <parameter>
        <name>fwhm_small</name>
        <value>1.0</value>
      </parameter>
      <parameter>
        <name>fwhm_large</name>
        <value>2.0</value>
      </parameter>
      <parameter>
        <name>kernel_size</name>
        <value>3</value>
      </parameter>
    </parameters>
  </inputs>
  
  <expected_outputs>
    <numeric_checks>
      <!-- Peak reduction after smoothing -->
      <check>
        <type>relative</type>
        <name>peak_reduction_small</name>
        <location>smooth_small[3,3,3]</location>
        <expected>85.0</expected>
        <tolerance>5.0</tolerance>
      </check>
      
      <check>
        <type>relative</type>
        <name>peak_reduction_large</name>
        <location>smooth_large[3,3,3]</location>
        <expected>65.0</expected>
        <tolerance>10.0</tolerance>
      </check>
      
      <!-- Signal spreading - edge values increase -->
      <check>
        <type>relative</type>
        <name>edge_increase_small</name>
        <location>smooth_small[1,3,3]</location>
        <expected>8.0</expected>
        <tolerance>2.0</tolerance>
      </check>
      
      <check>
        <type>relative</type>
        <name>edge_increase_large</name>
        <location>smooth_large[1,3,3]</location>
        <expected>12.0</expected>
        <tolerance>3.0</tolerance>
      </check>
      
      <!-- Total signal conservation -->
      <check>
        <type>relative</type>
        <name>signal_conservation_small</name>
        <location>sum(smooth_small)</location>
        <expected>500.0</expected>
        <tolerance>10.0</tolerance>
      </check>
      
      <check>
        <type>relative</type>
        <name>signal_conservation_large</name>
        <location>sum(smooth_large)</location>
        <expected>500.0</expected>
        <tolerance>15.0</tolerance>
      </check>
      
      <!-- Background smoothing -->
      <check>
        <type>relative</type>
        <name>background_smooth_small</name>
        <location>smooth_small[1,1,1]</location>
        <expected>0.007716</expected>
        <tolerance>0.0001</tolerance>
      </check>
      
      <check>
        <type>relative</type>
        <name>background_smooth_large</name>
        <location>smooth_large[1,1,1]</location>
        <expected>0.20</expected>
        <tolerance>0.05</tolerance>
      </check>
      
      <!-- Kernel properties -->
      <check>
        <type>relative</type>
        <name>kernel_normalization</name>
        <location>kernel_sum</location>
        <expected>1.0</expected>
        <tolerance>1e-6</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>kernel_symmetry</name>
        <location>kernel_symmetric</location>
        <expected>1</expected>
      </check>
      
      <!-- Smoothing order verification -->
      <check>
        <type>logical</type>
        <name>smoothing_order</name>
        <location>small_peak_gt_large_peak</location>
        <expected>true</expected>
      </check>
    </numeric_checks>
  </expected_outputs>
  
  <implementations>
    <R><![CDATA[
library(neuroim2)

# Create test space
space <- NeuroSpace(dim = c(5, 5, 5), 
                    spacing = c(1, 1, 1), 
                    origin = c(0, 0, 0))

# Create test volume with central peak
test_data <- array(c(
  # z=1
  0, 0, 0, 0, 0,
  0, 1, 2, 1, 0,
  0, 2, 10, 2, 0,
  0, 1, 2, 1, 0,
  0, 0, 0, 0, 0,
  # z=2
  0, 1, 2, 1, 0,
  1, 2, 5, 2, 1,
  2, 5, 20, 5, 2,
  1, 2, 5, 2, 1,
  0, 1, 2, 1, 0,
  # z=3 (center)
  0, 2, 10, 2, 0,
  2, 5, 20, 5, 2,
  10, 20, 100, 20, 10,
  2, 5, 20, 5, 2,
  0, 2, 10, 2, 0,
  # z=4
  0, 1, 2, 1, 0,
  1, 2, 5, 2, 1,
  2, 5, 20, 5, 2,
  1, 2, 5, 2, 1,
  0, 1, 2, 1, 0,
  # z=5
  0, 0, 0, 0, 0,
  0, 1, 2, 1, 0,
  0, 2, 10, 2, 0,
  0, 1, 2, 1, 0,
  0, 0, 0, 0, 0
), dim = c(5, 5, 5))

vol <- NeuroVol(test_data, space)

# Create a mask for the entire volume
mask_data <- array(TRUE, dim = c(5, 5, 5))
mask <- LogicalNeuroVol(mask_data, space)

# Apply Gaussian smoothing with different sigma values (approximating FWHM)
# FWHM ≈ 2.355 * sigma, so FWHM=1.0 → sigma≈0.42, FWHM=2.0 → sigma≈0.85
smooth_small <- gaussian_blur(vol, mask = mask, sigma = 0.42, window = 2)
smooth_large <- gaussian_blur(vol, mask = mask, sigma = 0.85, window = 2)

# Simple kernel properties test - create a small test kernel manually
test_kernel_size <- 3
kernel_values <- dnorm(-1:1, mean = 0, sd = 0.42)
kernel_1d <- kernel_values / sum(kernel_values)
kernel_sum <- sum(kernel_1d)
kernel_symmetric <- as.numeric(all.equal(kernel_1d, rev(kernel_1d)))

# Extract test values
peak_small <- smooth_small[3, 3, 3]
peak_large <- smooth_large[3, 3, 3]
edge_small <- smooth_small[1, 3, 3]
edge_large <- smooth_large[1, 3, 3]
bg_small <- smooth_small[1, 1, 1]
bg_large <- smooth_large[1, 1, 1]

# Signal conservation
sum_small <- sum(smooth_small)
sum_large <- sum(smooth_large)

# Smoothing order
small_peak_gt_large_peak <- as.numeric(peak_small > peak_large)
]]></R>
  </implementations>
  
  <propagation_status>
    <implementation lang="R" status="complete" date="2025-01-06"/>
    <implementation lang="Python" status="pending"/>
    <implementation lang="Rust" status="pending"/>
  </propagation_status>
</golden_test>