<?xml version="1.0" encoding="UTF-8"?>
<golden_test xmlns="http://golden-tests.org/schema">
  <metadata>
    <id>sparse_neurovol_operations</id>
    <version>1.0</version>
    <description>Test SparseNeuroVol construction and operations</description>
    <tags>
      <tag>volume_operations</tag>
      <tag>sparse</tag>
      <tag>core</tag>
    </tags>
  </metadata>
  
  <semantic_description>
    <purpose>
      Validate SparseNeuroVol creation from dense volumes with thresholding,
      arithmetic operations between sparse volumes, and conversion back to dense format.
    </purpose>
    <algorithm>
      1. Create a 4x4x4 dense NeuroVol with specific pattern (mostly zeros)
      2. Set only 6 voxels to non-zero values at known locations
      3. Convert to SparseNeuroVol using threshold > 0
      4. Verify correct number of non-zero values
      5. Test arithmetic operations between two sparse volumes
      6. Convert back to dense and verify values preserved
      7. Test indexing into sparse volume
    </algorithm>
  </semantic_description>
  
  <inputs>
    <array>
      <name>dense_data1</name>
      <dimensions>4 4 4</dimensions>
      <values>
        0 0 0 0 0 5 0 0 0 0 10 0 0 0 0 0
        0 0 0 0 0 0 0 0 0 0 0 15 0 0 0 0
        0 0 0 0 0 0 0 0 20 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0 0 0 0 0 25 0 0
      </values>
    </array>
    <array>
      <name>dense_data2</name>
      <dimensions>4 4 4</dimensions>
      <values>
        0 0 0 0 0 2 0 0 0 0 3 0 0 0 0 0
        0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0
        0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0
      </values>
    </array>
    <scalar>
      <name>threshold</name>
      <value>0</value>
    </scalar>
  </inputs>
  
  <expected_outputs>
    <numeric_checks>
      <!-- Check number of non-zero elements -->
      <check>
        <type>exact_value</type>
        <name>nnz_sparse1</name>
        <location>nnz1</location>
        <expected>5</expected>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>nnz_sparse2</name>
        <location>nnz2</location>
        <expected>5</expected>
      </check>
      
      <!-- Check specific sparse values -->
      <check>
        <type>exact_value</type>
        <name>sparse1_value_at_2_2_1</name>
        <location>sparse1[2,2,1]</location>
        <expected>5</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>sparse1_value_at_3_2_1</name>
        <location>sparse1[3,2,1]</location>
        <expected>10</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <!-- Check sparse arithmetic -->
      <check>
        <type>exact_value</type>
        <name>sparse_add_nnz</name>
        <location>sum(sparse_add != 0)</location>
        <expected>5</expected>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>sparse_add_value_at_2_2_1</name>
        <location>sparse_add[2,2,1]</location>
        <expected>7</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>sparse_mult_value_at_3_2_1</name>
        <location>sparse_mult[3,2,1]</location>
        <expected>30</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <!-- Check conversion back to dense -->
      <check>
        <type>exact_value</type>
        <name>dense_from_sparse_sum</name>
        <location>sum(dense_back)</location>
        <expected>75</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>dense_from_sparse_nnz</name>
        <location>sum(dense_back &gt; 0)</location>
        <expected>5</expected>
      </check>
      
      <!-- Check sparse with scalar -->
      <check>
        <type>exact_value</type>
        <name>sparse_scalar_mult_max</name>
        <location>max(sparse_scalar)</location>
        <expected>50</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <!-- Check values vector from sparse -->
      <check>
        <type>exact_value</type>
        <name>sparse_values_sorted</name>
        <location>sort(sparse_vals)</location>
        <expected>5 10 15 20 25</expected>
        <tolerance>1e-10</tolerance>
      </check>
    </numeric_checks>
  </expected_outputs>
  
  <implementations>
    <R><![CDATA[
library(neuroim2)

# Create test space
space <- NeuroSpace(dim = c(4, 4, 4), 
                    spacing = c(1, 1, 1), 
                    origin = c(0, 0, 0))

# Create first dense volume with sparse data
dense_data1 <- array(0, dim = c(4, 4, 4))
dense_data1[2, 2, 1] <- 5
dense_data1[3, 2, 1] <- 10
dense_data1[4, 3, 2] <- 15
dense_data1[1, 1, 3] <- 20
dense_data1[2, 4, 4] <- 25

vol1 <- NeuroVol(dense_data1, space)

# Create second dense volume
dense_data2 <- array(0, dim = c(4, 4, 4))
dense_data2[2, 2, 1] <- 2
dense_data2[3, 2, 1] <- 3
dense_data2[4, 3, 2] <- 4
dense_data2[1, 1, 3] <- 5
dense_data2[2, 4, 4] <- 6

vol2 <- NeuroVol(dense_data2, space)

# Convert to sparse - get indices of non-zero voxels
indices1 <- which(vol1 > 0)
indices2 <- which(vol2 > 0)

# Create sparse volumes with data and indices
sparse1 <- SparseNeuroVol(data = as.vector(vol1)[indices1], 
                          space = space, 
                          indices = indices1)
sparse2 <- SparseNeuroVol(data = as.vector(vol2)[indices2], 
                          space = space, 
                          indices = indices2)

# Get number of non-zero elements
nnz1 <- sum(sparse1 != 0)
nnz2 <- sum(sparse2 != 0)

# Test arithmetic operations
sparse_add <- sparse1 + sparse2
sparse_mult <- sparse1 * sparse2

# For scalar operations, need to create a constant sparse volume
const_vol <- NeuroVol(array(2, dim = c(4, 4, 4)), space)
const_sparse <- SparseNeuroVol(data = rep(2, length(indices1)), 
                               space = space, 
                               indices = indices1)
sparse_scalar <- sparse1 * const_sparse

# Get specific values
val_2_2_1 <- sparse1[2, 2, 1]
val_3_2_1 <- sparse1[3, 2, 1]
add_val_2_2_1 <- sparse_add[2, 2, 1]
mult_val_3_2_1 <- sparse_mult[3, 2, 1]

# Count non-zeros in result  
nnz_add <- sum(sparse_add != 0)

# Convert back to dense
dense_array <- as(sparse1, "array")
dense_back <- NeuroVol(dense_array, space)

# Get max of scalar multiplication
max_scalar <- max(sparse_scalar)

# Get values from sparse volume - only non-zero values
all_vals <- values(sparse1)
sparse_vals <- all_vals[all_vals != 0]
]]></R>
  </implementations>
  
  <propagation_status>
    <implementation lang="R" status="complete" date="2025-01-06"/>
    <implementation lang="Python" status="pending"/>
    <implementation lang="Rust" status="pending"/>
  </propagation_status>
</golden_test>