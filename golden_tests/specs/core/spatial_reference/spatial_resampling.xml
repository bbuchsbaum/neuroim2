<?xml version="1.0" encoding="UTF-8"?>
<golden_test xmlns="http://golden-tests.org/schema">
  <metadata>
    <id>spatial_resampling_transform</id>
    <version>1.0</version>
    <description>Test spatial resampling and coordinate transformation between different NeuroSpaces</description>
    <tags>
      <tag>spatial_reference</tag>
      <tag>resampling</tag>
      <tag>interpolation</tag>
      <tag>core</tag>
    </tags>
  </metadata>
  
  <semantic_description>
    <purpose>
      Validate spatial resampling operations including coordinate transformations,
      interpolation methods, and resampling between different resolution spaces
      using realistic neuroimaging data with proper transformation matrices.
    </purpose>
    <algorithm>
      1. Load real neuroimaging mask file (64x64x25, 3.5mm spacing)
      2. Create upsampled target space (128x128x50, 1.75mm spacing)
      3. Create downsampled target space (32x32x12, 7mm spacing)
      4. Test nearest neighbor interpolation (preserves binary values)
      5. Test linear interpolation (smooth transitions)
      6. Test coordinate transformation accuracy using proper transformation matrices
      7. Verify interpolation preserves signal characteristics and ranges
      8. Test volume preservation properties across different resolutions
    </algorithm>
  </semantic_description>
  
  <inputs>
    <file>
      <name>source_file</name>
      <path>system.file("extdata", "global_mask_v4.nii", package = "neuroim2")</path>
      <description>Real neuroimaging binary mask file (64x64x25, 3.5mm isotropic)</description>
    </file>
    <space>
      <name>target_space_upsample</name>
      <dimensions>128 128 50</dimensions>
      <spacing>1.75 1.75 1.85</spacing>
      <description>Double resolution target space</description>
    </space>
    <space>
      <name>target_space_downsample</name>
      <dimensions>32 32 12</dimensions>
      <spacing>7.0 7.0 7.4</spacing>
      <description>Half resolution target space</description>
    </space>
    <parameters>
      <parameter>
        <name>interp_nearest</name>
        <value>0</value>
      </parameter>
      <parameter>
        <name>interp_linear</name>
        <value>1</value>
      </parameter>
      <parameter>
        <name>interp_cubic</name>
        <value>3</value>
      </parameter>
    </parameters>
  </inputs>
  
  <expected_outputs>
    <numeric_checks>
      <!-- Upsampling with nearest neighbor -->
      <check>
        <type>exact_value</type>
        <name>upsample_nearest_corner</name>
        <location>upsample_nearest[1,1,1]</location>
        <expected>0</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>upsample_nearest_center</name>
        <location>upsample_nearest[64,64,25]</location>
        <expected>1</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>upsample_nearest_far</name>
        <location>upsample_nearest[128,128,50]</location>
        <expected>0</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <!-- Upsampling with linear interpolation -->
      <check>
        <type>exact_value</type>
        <name>upsample_linear_corner</name>
        <location>upsample_linear[1,1,1]</location>
        <expected>0</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>upsample_linear_interpolated</name>
        <location>upsample_linear[64,64,25]</location>
        <expected>1</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>upsample_linear_far</name>
        <location>upsample_linear[128,128,50]</location>
        <expected>0</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <!-- Downsampling (averaging) -->
      <check>
        <type>exact_value</type>
        <name>downsample_average</name>
        <location>downsample_result[16,16,6]</location>
        <expected>1</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <!-- Volume preservation with linear interpolation -->
      <check>
        <type>relative</type>
        <name>volume_preservation_ratio</name>
        <location>volume_ratio</location>
        <expected>0.993</expected>
        <tolerance>0.01</tolerance>
      </check>
      
      <!-- Coordinate transformation accuracy -->
      <check>
        <type>relative</type>
        <name>coord_transform_x</name>
        <location>world_coord_x</location>
        <expected>3.5</expected>
        <tolerance>1e-6</tolerance>
      </check>
      
      <check>
        <type>relative</type>
        <name>coord_transform_y</name>
        <location>world_coord_y</location>
        <expected>0.5</expected>
        <tolerance>1e-6</tolerance>
      </check>
      
      <check>
        <type>relative</type>
        <name>coord_transform_z</name>
        <location>world_coord_z</location>
        <expected>-5.5</expected>
        <tolerance>1e-6</tolerance>
      </check>
      
      <!-- Interpolation smoothness -->
      <check>
        <type>exact_value</type>
        <name>linear_smoother_than_nearest</name>
        <location>linear_smoother</location>
        <expected>1</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <!-- Range preservation for binary mask -->
      <check>
        <type>exact_value</type>
        <name>min_value_preserved</name>
        <location>min_linear</location>
        <expected>0</expected>
        <tolerance>1e-10</tolerance>
      </check>
      
      <check>
        <type>exact_value</type>
        <name>max_value_preserved</name>
        <location>max_linear</location>
        <expected>1</expected>
        <tolerance>1e-10</tolerance>
      </check>
    </numeric_checks>
  </expected_outputs>
  
  <implementations>
    <R><![CDATA[
library(neuroim2)

# Load real neuroimaging data as source
source_vol <- read_vol(system.file("extdata", "global_mask_v4.nii", package = "neuroim2"))
source_space <- space(source_vol)

# Create target spaces using proper transformation matrices
# Upsample: double resolution (64x64x25 -> 128x128x50)
target_space_up <- NeuroSpace(
  dim = dim(source_space) * 2, 
  spacing = spacing(source_space) / 2, 
  origin = origin(source_space), 
  trans = trans(source_space)
)

# Downsample: half resolution (64x64x25 -> 32x32x12) 
target_space_down <- NeuroSpace(
  dim = c(32, 32, 12), 
  spacing = spacing(source_space) * 2, 
  origin = origin(source_space), 
  trans = trans(source_space)
)

# Perform resampling operations (interpolation: 0=nearest, 1=trilinear, 3=cubic)
upsample_nearest <- resample(source_vol, target_space_up, interpolation = 0L)
upsample_linear <- resample(source_vol, target_space_up, interpolation = 1L)
downsample_result <- resample(source_vol, target_space_down, interpolation = 1L)

# Test coordinate transformation
voxel_coord <- c(32, 32, 12)  # Center voxel in source space
world_coord <- grid_to_coord(source_space, matrix(voxel_coord, nrow = 1))
world_coord_x <- world_coord[1, 1]
world_coord_y <- world_coord[1, 2]
world_coord_z <- world_coord[1, 3]

# Volume preservation test (approximate due to interpolation)
source_sum <- sum(source_vol, na.rm = TRUE) * prod(spacing(source_space))
upsampled_sum <- sum(upsample_linear, na.rm = TRUE) * prod(spacing(target_space_up))
volume_ratio <- upsampled_sum / source_sum

# Smoothness comparison (linear should be smoother than nearest neighbor)
nearest_var <- var(as.vector(upsample_nearest), na.rm = TRUE)
linear_var <- var(as.vector(upsample_linear), na.rm = TRUE)
linear_smoother <- as.numeric(linear_var < nearest_var)

# Extract specific values for testing
ups_near_corner <- upsample_nearest[1, 1, 1]
ups_near_center <- upsample_nearest[64, 64, 25]
ups_near_far <- upsample_nearest[128, 128, 50]

ups_lin_corner <- upsample_linear[1, 1, 1]
ups_lin_interp <- upsample_linear[64, 64, 25]
ups_lin_far <- upsample_linear[128, 128, 50]

down_avg <- downsample_result[16, 16, 6]

# Range checks
min_linear <- min(upsample_linear, na.rm = TRUE)
max_linear <- max(upsample_linear, na.rm = TRUE)
]]></R>
  </implementations>
  
  <propagation_status>
    <implementation lang="R" status="complete" date="2025-01-06"/>
    <implementation lang="Python" status="pending"/>
    <implementation lang="Rust" status="pending"/>
  </propagation_status>
</golden_test>