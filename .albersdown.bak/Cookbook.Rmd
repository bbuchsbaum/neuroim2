---
title: "neuroim2 Cookbook"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{neuroim2 Cookbook}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(neuroim2)
library(purrr)
library(assertthat)
```

This vignette collects small, task‑oriented examples (“cookbook” style)
for common `NeuroVec` workflows that don’t warrant a full standalone vignette.

We assume basic familiarity with `NeuroVec` from `vignette("NeuroVector")`.

## Reducing a 4D NeuroVec over time into a NeuroVol

Sometimes you want to take a 4D time‑series (`NeuroVec`) and collapse the
time dimension into a single 3D volume by applying a reduction function
to each voxel’s time‑series (e.g., temporal mean, standard deviation, or
any custom summary).

The pattern is:

1. Convert the `NeuroVec` to a voxel × time matrix with `as.matrix()`.
2. Apply a function over the time axis for each voxel (row).
3. Reshape back to 3D and wrap as a `NeuroVol`.

```{r}
file_name <- system.file("extdata", "global_mask_v4.nii", package = "neuroim2")
vec <- read_vec(file_name)  # 4D NeuroVec

reduce_ts_to_vol <- function(x, FUN) {
  dm <- dim(x)
  stopifnot(length(dm) == 4)
  mat <- as.matrix(x)         # voxels × time
  vals <- apply(mat, 1, FUN)  # one value per voxel
  NeuroVol(array(vals, dm[1:3]), drop_dim(space(x)))
}

# Example: temporal mean volume
mean_vol <- reduce_ts_to_vol(vec, mean)
mean_vol
```

You can plug in any summary function that maps a numeric vector to a
single value (e.g. `median`, a trimmed mean, robust summaries, etc.).

## Splitting a NeuroVec into blocks by an index vector

If you have a single concatenated `NeuroVec` with multiple logical
blocks along the time dimension (e.g., runs or sessions), you can
“un‑concatenate” it into one `NeuroVec` per block using
`split_blocks()`.

Create an index vector of length `dim(vec)[4]` indicating which block
each timepoint belongs to, then call `split_blocks()`:

```{r}
space4 <- NeuroSpace(c(10, 10, 10, 9), c(1, 1, 1))
vec4d  <- NeuroVec(array(rnorm(10 * 10 * 10 * 9),
                         dim = c(10, 10, 10, 9)),
                   space4)

# Suppose timepoints 1–3 belong to block 1, 4–6 to block 2, 7–9 to block 3
block_idx <- c(1, 1, 1,
               2, 2, 2,
               3, 3, 3)

blocks <- split_blocks(vec4d, block_idx)

length(blocks)        # 3 blocks
dim(blocks[[1]])      # first block: 10×10×10×3
dim(blocks[[2]])      # second block: 10×10×10×3
dim(blocks[[3]])      # third block: 10×10×10×3
```

The result is a deferred list (`deflist`) of `NeuroVec` objects; access
elements with `blocks[[i]]` to materialize a concrete `NeuroVec` for
block `i`. This is effectively the inverse of concatenation by time.


## Converting a NeuroVec to a memory‑mapped MappedNeuroVec

For large 4D datasets or shared‑memory workflows on HPC, it is often
useful to back a `NeuroVec` by a memory‑mapped file using
`MappedNeuroVec`. The `as_mmap()` helper converts common vector types
(`NeuroVec`, `SparseNeuroVec`, `FileBackedNeuroVec`) into a
`MappedNeuroVec`, writing an uncompressed NIfTI file if needed.

```{r}
file_name <- system.file("extdata", "global_mask_v4.nii", package = "neuroim2")
vec <- read_vec(file_name)  # DenseNeuroVec in memory

# Convert to a memory-mapped representation backed by a temporary .nii file
mvec <- as_mmap(vec)
mvec

# Or explicitly choose an output file (must be uncompressed for mmap)
tmp_nii <- tempfile(fileext = ".nii")
mvec2   <- as_mmap(vec, file = tmp_nii, overwrite = TRUE)

inherits(mvec2, "MappedNeuroVec")
```

For sparse data (`SparseNeuroVec`), `as_mmap()` first densifies the
vector and then writes a full 4D NIfTI before mapping it, trading memory
once for much more efficient subsequent access and multi‑process
sharing.


## Mapping a kernel over a 3D NeuroVol with `mapf`

To apply a spatial kernel (e.g. a 3×3×3 mean filter) over a 3D volume,
use `mapf()` with a `Kernel` object. This keeps the familiar
`NeuroVol`/`NeuroSpace` metadata while doing neighborhood computations.

```{r}
bspace <- NeuroSpace(c(10, 10, 10), c(1, 1, 1))
vol    <- NeuroVol(array(rnorm(10 * 10 * 10), c(10, 10, 10)), bspace)

# Simple 3×3×3 mean kernel
kern <- Kernel(c(3, 3, 3), vdim = c(3, 3, 3))

smoothed_vol <- mapf(vol, kern)
smoothed_vol
```

You can also pass a logical mask to restrict computation to a region
while keeping the output volume in the original space.


## Splitting a NeuroVec into ROIs by voxel clusters

Given voxelwise cluster labels (for example, from a parcellation),
`split_clusters()` can turn a `NeuroVec` into a list of `ROIVec`
objects—one per cluster—each containing the time‑series of voxels in
that cluster.

```{r}
file_name <- system.file("extdata", "global_mask_v4.nii", package = "neuroim2")
vec <- read_vec(file_name)

# Fake cluster labels over the full 3D grid
n_vox  <- prod(dim(vec)[1:3])
cl_lab <- sample(1:5, n_vox, replace = TRUE)

roi_list <- split_clusters(vec, cl_lab)

length(roi_list)   # number of non-empty clusters
roi_list[[1]]      # ROIVec for cluster "1"
coords(roi_list[[1]])[1:5, ]   # first few voxel coordinates
dim(values(roi_list[[1]]))     # time × voxels in that cluster
```

This is useful when you want to work directly with voxel‑level ROIs per
cluster rather than first building a `ClusteredNeuroVec`.
