% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cgb.R
\name{cgb_filter}
\alias{cgb_filter}
\title{Correlation-guided bilateral filtering (convenience wrapper)}
\usage{
cgb_filter(
  runs,
  mask = NULL,
  spatial_sigma = 2,
  window = NULL,
  corr_map = c("power", "exp", "soft"),
  corr_param = 2,
  topk = 16L,
  passes = 1L,
  lambda = 1,
  leave_one_out = FALSE,
  run_weights = NULL,
  add_self = TRUE,
  time_weights = NULL,
  confounds = NULL,
  robust = c("none", "huber", "tukey"),
  robust_c = 1.345,
  return_graph = FALSE
)
}
\arguments{
\item{runs}{A \code{\linkS4class{NeuroVec}} or a list of \code{NeuroVec}.}

\item{mask}{Optional \code{\linkS4class{LogicalNeuroVol}}/\code{NeuroVol} or
logical array for spatial masking. Defaults to in-mask voxels.}

\item{spatial_sigma}{Spatial Gaussian sigma in mm. Used both for weighting
and, when \code{window} is \code{NULL}, to auto-choose the neighborhood size.}

\item{window}{Integer half-width of the cubic neighborhood. If \code{NULL},
it is computed as \code{ceiling(2 * spatial_sigma / min(spacing))} and at
least 1.}

\item{corr_map}{Mapping from pooled correlation to affinity; one of
\code{"power"}, \code{"exp"}, or \code{"soft"}. Defaults to \code{"power"}.}

\item{corr_param}{Parameter for \code{corr_map} (gamma/tau/r0 respectively).}

\item{topk}{Keep strongest \code{k} neighbors (0 keeps all). Defaults to 16.}

\item{passes}{Number of smoothing passes (>=1). Defaults to 1.}

\item{lambda}{Blend factor in [0,1] per pass. Defaults to 1 (pure diffusion).}

\item{leave_one_out}{If \code{TRUE} and multiple runs are supplied, builds
LORO graphs and returns a list of smoothed runs.}

\item{run_weights}{Optional numeric weights per run for Fisher-z pooling.}

\item{add_self}{Logical; add a tiny self-edge before normalization.}

\item{time_weights}{Optional list (or single vector) of per-run time weights.}

\item{confounds}{Optional list (or single matrix) of per-run confounds.}

\item{robust}{One of \code{"none"}, \code{"huber"}, or \code{"tukey"}.}

\item{robust_c}{Tuning constant for robust weights.}

\item{return_graph}{Logical; if \code{TRUE}, also return the graph(s)
alongside the smoothed data.}
}
\value{
If \code{leave_one_out=FALSE}, a smoothed \code{NeuroVec}. If
  \code{leave_one_out=TRUE}, a list of smoothed \code{NeuroVec}. When
  \code{return_graph=TRUE}, returns a list with elements \code{result} and
  \code{graph} (single object or lists accordingly).
}
\description{
High-level interface that builds a correlation-guided bilateral (CGB) graph
with sensible defaults (similar to the bilateral filter interface) and
immediately applies it to smooth the data.
}
\details{
This is a convenience front-end to \code{cgb_make_graph} and
\code{cgb_smooth} with a bilateral-like interface:
- If \code{window} is \code{NULL}, it is chosen as
  \code{ceiling(2 * spatial_sigma / min(spacing))} (at least 1).
- Defaults target moderate smoothing: \code{corr_map = "power"},
  \code{corr_param = 2}, \code{topk = 16}, one pass with \code{lambda = 1}.
- Set \code{leave_one_out = TRUE} for multi-run inputs to avoid leakage.
- Use \code{return_graph = TRUE} to inspect or reuse the constructed graph(s).
}
\examples{
\donttest{
vec <- read_vec(system.file("extdata", "global_mask_v4.nii", package = "neuroim2"))
mask <- read_vol(system.file("extdata", "global_mask_v4.nii", package = "neuroim2"))

# Auto window from spatial_sigma and spacing, single pass
out <- cgb_filter(vec, mask, spatial_sigma = 3, window = NULL, topk = 16)

# Stronger diffusion with two passes and lambda < 1
out2 <- cgb_filter(vec, mask, spatial_sigma = 4, window = NULL,
                   passes = 2, lambda = 0.7)
}

}
